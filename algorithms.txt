算法流程：
1.初始化三个订单
2.产生新的订单：
    1).产生价差分布:x~t(n)
    2).产生订单提交类型分布(+1/-1):order_sign 用分形高斯随机过程产生
    3).计算当前best_bid, best_ask及s=best_ask-best_bid
    4).根据以下不同情况处理：
        订单类型(+1:买入订单)：
            x<s:计算price_bid=x+best_bid并加入买入订单簿
            x>=s:
                如果卖出订单的数目不少于2，则订单成交
                否则订单无效
        订单类型(-1:卖出订单)：
            x<s:计算price_ask=best_ask-x并加入卖出订单簿
            x>=s:
                如果买入订单的数目不少于2，则订单成交
                否则订单无效
3.订单取消：
    1).计算订单的不均衡度：
        imb_bid=n_bid/(n_ask+n_bid)
        imb_ask=n_ask/(n_ask+n_bid)
    2).计算最佳叫价的移动情况：
        分别计算以下不同情况下限价订单同最佳报价之间的相对差价：
            卖出订单：
                0时刻的差价：delta_i(0)_bid=pi-bid_best(该订单放置时候的最佳报价)
                t时刻的差价：delta_i(t)_bid=pi-bid_best(当前t时刻的最佳报价)
            买入订单：
                0时刻的差价：delta_i(0)=ask_best(该订单放置时候的最佳报价)-pi
                t时刻的差价：delta_i(t)=ask_best(当前t时刻的最佳报价)-pi
        计算叫价移动方向：
            卖出订单：y_ask=delta_i(t)_bid/delta_i(0)_bid
            买入订单：y_bid=delta_i(t)_ask/delta_i(0)_ask
    3).计算总订单量：
        n_tot=n_ask+b_bid
    4).计算订单取消的概率
        卖出订单：
            p_ask=A*(1-exp(-y_ask))(imb_ask+B)/n_tot
            p_ask<rand(0,1):订单取消
            p_ask>=rand(0,1):订单不取消
        买入订单：
            p_bid=A*(1-exp(-y_bid))(imb_bid+B)/n_tot
            p_bid<rand(0,1):订单取消
            p_bid>=rand(0,1):订单不取消
        
                